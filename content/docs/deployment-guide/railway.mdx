---
title: Deploy to Railway
description: Deploy your Motia app to Railway with Redis for production-grade backends
---

Railway makes deploying Motia apps dead simple. Connect your repo, add Redis, and you're live in minutes.

This guide walks you through deploying a production-ready Motia app with real Redis (not in-memory) on Railway.

<Callout type="info">
**What you'll get:** A fully containerized Motia app running on Railway with external Redis for state, events, streams, and cron locking.
</Callout>

---

## Prerequisites

Before you start:

- A [Railway account](https://railway.app) (free tier works)
- [Railway CLI](https://docs.railway.com/guides/cli) installed
- Docker running locally (for testing)
- A Motia project ready to deploy

Install the Railway CLI:

```bash
npm install -g @railway/cli
```

---

## Quick Start

<Steps>
<Step>
#### Login to Railway

```bash
railway login
```

This opens your browser for authentication.

</Step>
<Step>
#### Initialize your project

From your Motia project root:

```bash
railway init
```

Give your project a name when prompted.

</Step>
<Step>
#### Add Redis

```bash
railway add --plugin redis
```

Railway provisions a managed Redis instance automatically.

</Step>
<Step>
#### Deploy

```bash
railway up
```

Railway builds your Docker image and deploys it.

</Step>
<Step>
#### Get your public URL

```bash
railway domain
```

This assigns a public URL to your app. You're live!

</Step>
</Steps>

---

## Project Setup

### Docker Files

If you haven't already, generate the Docker files:

```bash
npx motia@latest docker setup
```

This creates `Dockerfile` and `.dockerignore` in your project.

### Update Your Start Script

Railway injects the port via the `PORT` environment variable. Update your `package.json`:

```json title="package.json"
{
  "scripts": {
    "start": "motia start --port ${PORT:-3000} --host 0.0.0.0"
  }
}
```

This ensures Motia listens on the port Railway expects.

### Railway Configuration

Create a `railway.json` in your project root:

```json title="railway.json"
{
  "$schema": "https://railway.app/railway.schema.json",
  "build": {
    "builder": "DOCKERFILE",
    "dockerfilePath": "Dockerfile"
  },
  "deploy": {
    "numReplicas": 1,
    "startCommand": "npm run start",
    "restartPolicyType": "ON_FAILURE",
    "restartPolicyMaxRetries": 10
  }
}
```

<Callout type="warn">
**Healthchecks:** Railway's default healthcheck expects a `200` response on `/`. If your app doesn't serve the root path, either add a health endpoint or remove healthcheck settings from `railway.json`.
</Callout>

---

## Configure Redis Adapters

For production, you want Motia to use Railway's Redis instead of the built-in memory server.

### Install Adapter Packages

```bash
npm install @motiadev/adapter-redis-state \
            @motiadev/adapter-redis-streams \
            @motiadev/adapter-redis-cron \
            @motiadev/adapter-bullmq-events
```

### Update motia.config.ts

```typescript title="motia.config.ts"
import { defineConfig } from '@motiadev/core'
import { RedisStateAdapter } from '@motiadev/adapter-redis-state'
import { RedisStreamAdapterManager } from '@motiadev/adapter-redis-streams'
import { RedisCronAdapter } from '@motiadev/adapter-redis-cron'
import { BullMQEventAdapter } from '@motiadev/adapter-bullmq-events'

// Parse REDIS_URL (Railway sets this automatically when you add Redis)
// Format: redis://default:password@host:port
const url = new URL(process.env.REDIS_URL || process.env.REDIS_PRIVATE_URL || 'redis://localhost:6379')

const redisConfig = {
  host: url.hostname,
  port: Number(url.port) || 6379,
  username: url.username || undefined,
  password: url.password || undefined,
  tls: url.protocol === 'rediss:',
}

export default defineConfig({
  adapters: {
    state: new RedisStateAdapter({
      socket: { host: redisConfig.host, port: redisConfig.port, tls: redisConfig.tls },
      username: redisConfig.username,
      password: redisConfig.password,
    }),
    streams: new RedisStreamAdapterManager({
      socket: { host: redisConfig.host, port: redisConfig.port, tls: redisConfig.tls },
      username: redisConfig.username,
      password: redisConfig.password,
    }),
    events: new BullMQEventAdapter({
      connection: {
        host: redisConfig.host,
        port: redisConfig.port,
        username: redisConfig.username,
        password: redisConfig.password,
        tls: redisConfig.tls ? {} : undefined,
        maxRetriesPerRequest: null,
      },
    }),
    cron: new RedisCronAdapter({
      socket: { host: redisConfig.host, port: redisConfig.port, tls: redisConfig.tls },
      username: redisConfig.username,
      password: redisConfig.password,
    }),
  },
})
```

<Callout type="info">
**That's it!** Railway auto-injects `REDIS_URL` when you link the Redis plugin to your service.
</Callout>

---

## Set Environment Variables

Railway auto-provisions Redis variables when you add the Redis plugin. Link them to your app:

<Steps>
<Step>
#### Link to your app service

```bash
railway service
```

Select your app service (not Redis).

</Step>
<Step>
#### Set the variables

```bash
railway variables --set "NODE_ENV=production"
railway variables --set "USE_REDIS=true"
railway variables --set "REDIS_URL=\${{Redis.REDIS_URL}}"
```

The `${{Redis.REDIS_URL}}` syntax tells Railway to inject the actual Redis URL at runtime.

</Step>
<Step>
#### Verify variables

```bash
railway variables
```

You should see your variables listed.

</Step>
</Steps>

<Callout type="warn">
**Internal vs Public URL:** Railway provides both internal (`redis.railway.internal`) and public proxy URLs for Redis. The internal URL only works within Railway's network. If you have connection issues, try the public URL from your Redis service's settings.
</Callout>

---

## Deploy and Test

### Deploy Your App

```bash
railway up
```

Watch the build logs. Once complete, Railway deploys your container.

### Get Your Domain

```bash
railway domain
```

Railway assigns a public URL like `https://your-app-production-xxxx.up.railway.app`.

### Test Your API

```bash
# List items (should be empty initially)
curl https://your-app-production-xxxx.up.railway.app/todos

# Create an item
curl -X POST https://your-app-production-xxxx.up.railway.app/todos \
  -H "Content-Type: application/json" \
  -d '{"title":"Test from Railway","priority":"high"}'

# List items again (should show your new item)
curl https://your-app-production-xxxx.up.railway.app/todos
```

If you get a JSON response with your data, you're running on production Redis!

---

## View Logs

Check what's happening in your deployed app:

```bash
railway logs
```

Add `--follow` to stream logs in real-time:

```bash
railway logs --follow
```

---

## Troubleshooting

### 502 Application Failed to Respond

**Cause:** Usually means the app isn't listening on the right port.

**Fix:** Make sure your start script uses `${PORT:-3000}`:

```json
"start": "motia start --port ${PORT:-3000} --host 0.0.0.0"
```

### Redis Connection Errors

**Cause:** The app can't reach Redis.

**Check:**
1. Is the Redis service running? Check Railway dashboard.
2. Is `REDIS_URL` set correctly? Run `railway variables` to verify.
3. Try the public Redis URL if internal isn't working.

### Healthcheck Failed

**Cause:** Railway expects a 200 response on your healthcheck path.

**Options:**
1. Remove healthcheck settings from `railway.json`
2. Add a health endpoint that returns 200
3. Increase the healthcheck timeout

### Still Seeing "Redis Memory Server Started"

**Cause:** The app is falling back to in-memory Redis.

**Check:**
1. Is `NODE_ENV=production` set?
2. Is `REDIS_URL` resolving correctly?
3. Check logs for Redis connection errors.

---

## Local Testing with Docker

Before deploying, test your production setup locally:

```yaml title="docker-compose.yml"
services:
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 10

  motia:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - REDIS_URL=redis://redis:6379
    depends_on:
      redis:
        condition: service_healthy
```

Run it:

```bash
docker-compose up --build
```

Test at `http://localhost:3000`. If it works here, it'll work on Railway.

---

## Scaling

Need more instances? Update your `railway.json`:

```json title="railway.json"
{
  "deploy": {
    "numReplicas": 3
  }
}
```

With Redis adapters configured, all instances share state, events, and streams. Requests get load-balanced automatically.

---

## What's Next?

<Cards>
  <Card href="/docs/deployment-guide/fly" title="Deploy to Fly.io">
    Alternative cloud platform with global edge deployment
  </Card>
  
  <Card href="/docs/deployment-guide/self-hosted" title="Self-Hosted">
    Full control with your own infrastructure
  </Card>
</Cards>
