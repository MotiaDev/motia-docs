---
title: Authentication
description: How to handle authentication in Motia for HTTP endpoints and real-time streams
---

Motia provides two authentication patterns: **stream authentication** configured via the iii engine's `config.yaml`, and **HTTP endpoint authentication** handled within your Step handlers.

## Stream Authentication

Stream authentication is configured in `config.yaml` on the Stream module via the `auth_function` field. This references a registered function that runs when clients connect to a WebSocket stream.

```yaml title="config.yaml"
  - class: modules::stream::StreamModule
    config:
      port: 3112
      host: 0.0.0.0
      auth_function: stream.authenticate
      adapter:
        class: modules::stream::adapters::KvStore
        config:
          store_method: file_based
          file_path: ./data/stream_store
```

Then create a Step that registers the authentication function:

```typescript title="src/stream-auth.step.ts"
import type { Handlers, StepConfig } from 'motia'

export const config = {
  name: 'StreamAuthenticate',
  description: 'Authenticates WebSocket stream connections',
  triggers: [],
  enqueues: [],
  flows: ['auth'],
} as const satisfies StepConfig

export const handler: Handlers<typeof config> = async (input, { logger }) => {
  const token = input.headers?.['authorization']

  if (!token) {
    return { unauthorized: true }
  }

  const user = await validateToken(token)
  logger.info('Stream authenticated', { userId: user.id })

  return { context: { userId: user.id, role: user.role } }
}
```

If the auth function returns `{ unauthorized: true }`, the connection is rejected. Otherwise, the returned `context` is available to stream subscription handlers.

---

## HTTP Endpoint Authentication

For HTTP endpoints, handle authentication directly in your Step handler using shared utility functions:

```typescript title="src/utils/auth.ts"
import type { ApiRequest } from 'motia'
import jwt from 'jsonwebtoken'

type TokenData = { userId: string; role: string }

export async function requireAuth(request: ApiRequest<any>): Promise<TokenData> {
  const authHeader = request.headers['authorization'] as string

  if (!authHeader) {
    throw new HttpError(401, 'Missing authorization header')
  }

  const [, token] = authHeader.split(' ')
  return jwt.verify(token, process.env.JWT_SECRET!) as TokenData
}

export class HttpError extends Error {
  constructor(public status: number, message: string) {
    super(message)
  }
}
```

Then use it in your Step handlers:

```typescript title="src/get-profile.step.ts"
import type { Handlers, StepConfig } from 'motia'
import { requireAuth, HttpError } from './utils/auth'

export const config = {
  name: 'GetProfile',
  description: 'Get authenticated user profile',
  triggers: [{ type: 'http', method: 'GET', path: '/profile' }],
  enqueues: [],
  flows: ['users'],
} as const satisfies StepConfig

export const handler: Handlers<typeof config> = async (req, { logger, state }) => {
  try {
    const tokenData = await requireAuth(req)
    const user = await state.get('users', tokenData.userId)

    return { status: 200, body: user }
  } catch (error) {
    if (error instanceof HttpError) {
      return { status: error.status, body: { error: error.message } }
    }
    return { status: 500, body: { error: 'Internal server error' } }
  }
}
```

---

## Error Handling

Wrap your handler logic in try/catch blocks for error handling. This replaces the previous middleware-based `coreMiddleware` pattern:

```typescript
export const handler: Handlers<typeof config> = async (req, { logger }) => {
  try {
    const result = await processRequest(req)
    return { status: 200, body: result }
  } catch (error) {
    logger.error('Request failed', { error: error.message })

    if (error instanceof HttpError) {
      return { status: error.status, body: { error: error.message } }
    }

    return { status: 500, body: { error: 'Internal server error' } }
  }
}
```

---

## Reusable Auth Wrappers

For a cleaner pattern across many Steps, create a wrapper function:

```typescript title="src/utils/with-auth.ts"
import type { ApiRequest, ApiResponse } from 'motia'
import { requireAuth, HttpError, type TokenData } from './auth'

export function withAuth<TBody>(
  fn: (req: ApiRequest<TBody>, tokenData: TokenData, ctx: any) => Promise<ApiResponse<any, any>>
) {
  return async (req: ApiRequest<TBody>, ctx: any) => {
    try {
      const tokenData = await requireAuth(req)
      return await fn(req, tokenData, ctx)
    } catch (error) {
      if (error instanceof HttpError) {
        return { status: error.status, body: { error: error.message } }
      }
      return { status: 500, body: { error: 'Internal server error' } }
    }
  }
}
```

```typescript title="src/protected-endpoint.step.ts"
import { withAuth } from './utils/with-auth'

export const handler = withAuth(async (req, tokenData, ctx) => {
  ctx.logger.info('Authenticated request', { userId: tokenData.userId })
  return { status: 200, body: { message: 'Protected content' } }
})
```
