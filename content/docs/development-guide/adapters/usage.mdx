---
title: Using Adapters
description: How to configure and use adapters in your Motia application
---

Adapters in Motia provide a pluggable infrastructure layer that enables horizontal scaling and custom implementations. They abstract the underlying infrastructure components (state storage, event handling, streams, and cron locking) so you can swap implementations without changing your application code.

## Adapter Types

Motia supports four main adapter types:

- **Streams**: Real-time data streams for live updates
- **State**: Persistent key-value storage shared across steps
- **Events**: Event-based communication between steps
- **Cron**: Distributed cron job locking to prevent duplicate executions

## Configuration

Adapters are configured in your `motia.config.ts` file. If no adapters are specified, Motia uses default implementations suitable for single-instance deployments.

### Default Adapters (No Configuration)

```typescript title="motia.config.ts"
import { config } from '@motiadev/core'

export default config({
  // Uses defaults:
  // - FileStateAdapter for state
  // - InMemoryQueueEventAdapter for events
  // - InMemoryCronAdapter for cron
  // - FileStreamAdapter for streams
})
```

### Custom Adapters

```typescript title="motia.config.ts"
import { config } from '@motiadev/core'
import { RedisStateAdapter } from '@motiadev/adapter-redis-state'
import { RedisStreamAdapterManager } from '@motiadev/adapter-redis-streams'
import { RabbitMQEventAdapter } from '@motiadev/adapter-rabbitmq-events'
import { RedisCronAdapter } from '@motiadev/adapter-redis-cron'

export default config({
  adapters: {
    state: new RedisStateAdapter({
      host: process.env.REDIS_HOST,
      port: 6379,
    }),
    streams: new RedisStreamAdapterManager({
      host: process.env.REDIS_HOST,
      port: 6379,
    }),
    events: new RabbitMQEventAdapter({
      url: process.env.RABBITMQ_URL,
      exchangeName: process.env.RABBITMQ_EXCHANGE || 'motia.events',
      exchangeType: 'topic',
    }),
    cron: new RedisCronAdapter({
      host: process.env.REDIS_HOST,
      port: 6379,
    }),
  },
})
```

## Usage in Code

### Stream Adapter

Streams are accessed via `context.streams` in your step handlers. Each stream is defined by a `.stream.ts` file and accessed by its name.

**Defining a Stream:**

<Tabs items={['TypeScript', 'Python', 'JavaScript']}>
<Tab value='TypeScript'>

```typescript title="steps/messages.stream.ts"
import { z } from 'zod'
import type { StreamConfig } from 'motia'

export const messageSchema = z.object({
  content: z.string(),
  userId: z.string(),
  timestamp: z.number(),
})

export type Message = z.infer<typeof messageSchema>

export const config: StreamConfig = {
  name: 'messages',
  schema: messageSchema,
  baseConfig: { storageType: 'default' },
}
```

</Tab>
<Tab value='Python'>

```python title="steps/messages_stream.py"
from pydantic import BaseModel

class Message(BaseModel):
    content: str
    user_id: str
    timestamp: int

config = {
    "name": "messages",
    "schema": Message.model_json_schema(),
    "baseConfig": {"storageType": "default"}
}
```

</Tab>
<Tab value='JavaScript'>

```javascript title="steps/messages.stream.js"
const config = {
  name: 'messages',
  schema: {
    type: 'object',
    properties: {
      content: { type: 'string' },
      userId: { type: 'string' },
      timestamp: { type: 'number' },
    },
    required: ['content', 'userId', 'timestamp'],
  },
  baseConfig: { storageType: 'default' },
}

module.exports = { config }
```

</Tab>
</Tabs>

**Using a Stream:**

<Tabs items={['TypeScript', 'Python', 'JavaScript']}>
<Tab value='TypeScript'>

```typescript title="steps/chat.step.ts"
import type { Handlers } from 'motia'

export const handler: Handlers['Chat'] = async (req, { streams }) => {
  // Set a stream item
  await streams.messages.set('chat-123', 'msg-1', {
    content: 'Hello!',
    userId: 'user-1',
    timestamp: Date.now(),
  })

  // Get a stream item
  const message = await streams.messages.get('chat-123', 'msg-1')

  // Get all items in a group
  const allMessages = await streams.messages.getGroup('chat-123')

  // Delete a stream item
  await streams.messages.delete('chat-123', 'msg-1')

  return { status: 200, body: { messages: allMessages } }
}
```

</Tab>
<Tab value='Python'>

```python title="steps/chat_step.py"
async def handler(req, context):
    # Set a stream item
    await context.streams.messages.set("chat-123", "msg-1", {
        "content": "Hello!",
        "userId": "user-1",
        "timestamp": int(time.time() * 1000),
    })

    # Get a stream item
    message = await context.streams.messages.get("chat-123", "msg-1")

    # Get all items in a group
    all_messages = await context.streams.messages.get_group("chat-123")

    # Delete a stream item
    await context.streams.messages.delete("chat-123", "msg-1")

    return {"status": 200, "body": {"messages": all_messages}}
```

</Tab>
<Tab value='JavaScript'>

```javascript title="steps/chat.step.js"
const handler = async (req, { streams }) => {
  // Set a stream item
  await streams.messages.set('chat-123', 'msg-1', {
    content: 'Hello!',
    userId: 'user-1',
    timestamp: Date.now(),
  })

  // Get a stream item
  const message = await streams.messages.get('chat-123', 'msg-1')

  // Get all items in a group
  const allMessages = await streams.messages.getGroup('chat-123')

  // Delete a stream item
  await streams.messages.delete('chat-123', 'msg-1')

  return { status: 200, body: { messages: allMessages } }
}

module.exports = { handler }
```

</Tab>
</Tabs>

### State Adapter

State is accessed via `context.state` and provides persistent storage scoped to a trace ID.

<Tabs items={['TypeScript', 'Python', 'JavaScript']}>
<Tab value='TypeScript'>

```typescript title="steps/processor.step.ts"
import type { Handlers } from 'motia'

export const handler: Handlers['Processor'] = async (req, { state, traceId }) => {
  // Set a value
  await state.set(traceId, 'userCount', 42)

  // Get a value
  const count = await state.get<number>(traceId, 'userCount')

  // Get all keys for a trace
  const keys = await state.keys(traceId)

  // Delete a value
  await state.delete(traceId, 'userCount')

  // Clear all state for a trace
  await state.clear(traceId)

  return { status: 200, body: { count } }
}
```

</Tab>
<Tab value='Python'>

```python title="steps/processor_step.py"
async def handler(req, context):
    # Set a value
    await context.state.set(context.trace_id, "userCount", 42)

    # Get a value
    count = await context.state.get(context.trace_id, "userCount")

    # Get all keys for a trace
    keys = await context.state.keys(context.trace_id)

    # Delete a value
    await context.state.delete(context.trace_id, "userCount")

    # Clear all state for a trace
    await context.state.clear(context.trace_id)

    return {"status": 200, "body": {"count": count}}
```

</Tab>
<Tab value='JavaScript'>

```javascript title="steps/processor.step.js"
const handler = async (req, { state, traceId }) => {
  // Set a value
  await state.set(traceId, 'userCount', 42)

  // Get a value
  const count = await state.get(traceId, 'userCount')

  // Get all keys for a trace
  const keys = await state.keys(traceId)

  // Delete a value
  await state.delete(traceId, 'userCount')

  // Clear all state for a trace
  await state.clear(traceId)

  return { status: 200, body: { count } }
}

module.exports = { handler }
```

</Tab>
</Tabs>

### Event Adapter

Events are used to trigger other steps. Use `context.emit()` to send events, and configure steps with `subscribes` to listen for events.

**Emitting Events:**

<Tabs items={['TypeScript', 'Python', 'JavaScript']}>
<Tab value='TypeScript'>

```typescript title="steps/order.step.ts"
import type { Handlers } from 'motia'

export const handler: Handlers['Order'] = async (req, { emit }) => {
  await emit({
    topic: 'order.created',
    data: { orderId: '123', amount: 99.99 },
  })

  return { status: 200, body: { success: true } }
}
```

</Tab>
<Tab value='Python'>

```python title="steps/order_step.py"
async def handler(req, context):
    await context.emit({
        "topic": "order.created",
        "data": {"orderId": "123", "amount": 99.99},
    })

    return {"status": 200, "body": {"success": True}}
```

</Tab>
<Tab value='JavaScript'>

```javascript title="steps/order.step.js"
const handler = async (req, { emit }) => {
  await emit({
    topic: 'order.created',
    data: { orderId: '123', amount: 99.99 },
  })

  return { status: 200, body: { success: true } }
}

module.exports = { handler }
```

</Tab>
</Tabs>

**Subscribing to Events:**

<Tabs items={['TypeScript', 'Python', 'JavaScript']}>
<Tab value='TypeScript'>

```typescript title="steps/notify.step.ts"
import type { EventConfig, Handlers } from 'motia'
import { z } from 'zod'

export const config: EventConfig = {
  name: 'Notify',
  type: 'event',
  subscribes: ['order.created'],
  input: z.object({
    orderId: z.string(),
    amount: z.number(),
  }),
}

export const handler: Handlers['Notify'] = async (input, { logger }) => {
  logger.info('Order received', { orderId: input.orderId })
  // Send notification...
}
```

</Tab>
<Tab value='Python'>

```python title="steps/notify_step.py"
from pydantic import BaseModel

class OrderInput(BaseModel):
    orderId: str
    amount: float

config = {
    "name": "Notify",
    "type": "event",
    "subscribes": ["order.created"],
    "input": OrderInput.model_json_schema(),
}

async def handler(input, context):
    context.logger.info("Order received", {"orderId": input.get("orderId")})
    # Send notification...
```

</Tab>
<Tab value='JavaScript'>

```javascript title="steps/notify.step.js"
const config = {
  name: 'Notify',
  type: 'event',
  subscribes: ['order.created'],
  input: {
    type: 'object',
    properties: {
      orderId: { type: 'string' },
      amount: { type: 'number' },
    },
    required: ['orderId', 'amount'],
  },
}

const handler = async (input, { logger }) => {
  logger.info('Order received', { orderId: input.orderId })
  // Send notification...
}

module.exports = { config, handler }
```

</Tab>
</Tabs>

### Cron Adapter

Cron adapters are automatically used by Motia when cron steps run. They provide distributed locking to ensure only one instance executes a cron job, even when running multiple Motia instances.

**Defining a Cron Step:**

<Tabs items={['TypeScript', 'Python', 'JavaScript']}>
<Tab value='TypeScript'>

```typescript title="steps/daily-report.step.ts"
import type { CronConfig, Handlers } from 'motia'

export const config: CronConfig = {
  name: 'DailyReport',
  type: 'cron',
  cron: '0 9 * * *', // Run daily at 9 AM
  flows: ['reports'],
}

export const handler: Handlers['DailyReport'] = async ({ emit, logger }) => {
  logger.info('Running daily report')
  await emit({
    topic: 'report.generated',
    data: { date: new Date().toISOString() },
  })
}
```

</Tab>
<Tab value='Python'>

```python title="steps/daily_report_step.py"
config = {
    "name": "DailyReport",
    "type": "cron",
    "cron": "0 9 * * *",  # Run daily at 9 AM
    "flows": ["reports"],
}

async def handler(context):
    context.logger.info("Running daily report")
    await context.emit({
        "topic": "report.generated",
        "data": {"date": datetime.now().isoformat()},
    })
```

</Tab>
<Tab value='JavaScript'>

```javascript title="steps/daily-report.step.js"
const config = {
  name: 'DailyReport',
  type: 'cron',
  cron: '0 9 * * *', // Run daily at 9 AM
  flows: ['reports'],
}

const handler = async ({ emit, logger }) => {
  logger.info('Running daily report')
  await emit({
    topic: 'report.generated',
    data: { date: new Date().toISOString() },
  })
}

module.exports = { config, handler }
```

</Tab>
</Tabs>

The cron adapter automatically:
- Acquires a lock before execution
- Releases the lock after completion
- Prevents duplicate executions across multiple instances

No additional code is needed to use the cron adapter - it works automatically when you configure a cron step.

### How Cron Adapter Works

When running multiple instances of a Motia application, each instance schedules the same cron jobs. Without coordination, this leads to duplicate executions. The Redis Cron Adapter solves this using distributed locking:

1. **Job Scheduling**: All instances schedule cron jobs normally
2. **Lock Acquisition**: When a cron job triggers, the instance attempts to acquire a distributed lock
3. **Execution**: Only the instance that successfully acquires the lock executes the job
4. **Lock Release**: After execution completes (or fails), the lock is released
5. **TTL Protection**: Locks have a TTL to prevent deadlocks if an instance crashes

**Execution Flow:**

```
Instance 1              Instance 2              Instance 3
    |                       |                       |
    | Cron triggers         | Cron triggers         | Cron triggers
    | (9:00 AM)             | (9:00 AM)             | (9:00 AM)
    |                       |                       |
    v                       v                       v
acquireLock()          acquireLock()          acquireLock()
    |                       |                       |
    v                       v                       v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Distributed Lock Store (Redis)              â”‚
â”‚                                                     â”‚
â”‚  Lock: daily-report                                â”‚
â”‚  Owner: instance-1                                 â”‚
â”‚  Acquired: 2025-10-22 09:00:00                    â”‚
â”‚  Expires: 2025-10-22 09:05:00                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    |                       |                       |
    v                       v                       v
Lock acquired âœ“        Lock failed âœ—          Lock failed âœ—
    |                       |                       |
    v                       |                       |
Execute job             Skip execution         Skip execution
    |                       |                       |
    v                       |                       |
releaseLock()              |                       |
```

### Lock TTL Selection

Choose the lock TTL based on your job execution times:

- **Short Jobs** (< 1 minute): Use 60000ms (1 minute) TTL
- **Medium Jobs** (1-5 minutes): Use 300000ms (5 minutes) TTL
- **Long Jobs** (> 5 minutes): Use 600000ms+ (10+ minutes) TTL

Configure the TTL in your adapter configuration:

```typescript title="motia.config.ts"
import { RedisCronAdapter } from '@motiadev/adapter-redis-cron'

export default config({
  adapters: {
    cron: new RedisCronAdapter({
      host: process.env.REDIS_HOST || 'localhost',
      port: 6379,
      lockTTL: 600000, // 10 minutes for long-running jobs
    }),
  },
})
```

### Edge Cases

**Instance Crashes**: If an instance crashes while holding a lock, the lock will expire after the TTL, allowing another instance to execute the job. This provides automatic recovery.

**Clock Skew**: Different instances might have slightly different system clocks, causing cron jobs to trigger at slightly different times. The lock mechanism ensures only one execution regardless of timing differences.

**Redis Unavailability**: If Redis is unavailable, all instances will fail to acquire locks and no cron jobs will execute. This is a fail-safe behavior to prevent duplicates.

### Development vs Production

**Development**: For development environments where horizontal scaling is not needed, you can omit the `cron` adapter from configuration. Cron jobs will execute normally without distributed locking, reducing external dependencies during development.

**Production**: For production with multiple instances, always configure a cron adapter. Use managed Redis services (AWS ElastiCache, etc.) for high availability, set appropriate lock TTLs based on job execution times, and monitor active locks to ensure proper coordination.

## Available Implementations

### Official Packages

- `@motiadev/adapter-redis-state` - Redis-based state storage
- `@motiadev/adapter-redis-streams` - Redis streams implementation
- `@motiadev/adapter-redis-cron` - Redis distributed locking for cron
- `@motiadev/adapter-rabbitmq-events` - RabbitMQ event handling

### Default Implementations

These are included in `@motiadev/core` and work without external dependencies:

- `FileStateAdapter` - File-based state (default)
- `MemoryStateAdapter` - In-memory state (testing)
- `FileStreamAdapter` - File-based streams (default)
- `MemoryStreamAdapter` - In-memory streams (testing)
- `InMemoryQueueEventAdapter` - In-memory event queue (default)
- `InMemoryCronAdapter` - Single-instance cron locking (default)

## When to Use Custom Adapters

**Use default adapters when:**
- Running a single Motia instance
- Local development
- Testing

**Use distributed adapters (Redis, RabbitMQ) when:**
- Running multiple Motia instances
- Need horizontal scaling
- Production deployments
- High availability requirements

---

## What's Next?

<Cards>
  <Card href="/docs/development-guide/adapters/creating-adapters" title="ğŸ”§ Creating Adapters">
    Learn how to create custom adapters
  </Card>
  
  <Card href="/docs/development-guide/state-management" title="ğŸ“¦ State Management">
    Learn more about state management
  </Card>
</Cards>

